import os
import tempfile
from typing import List, Optional, Dict, Any
import streamlit as st
from datetime import datetime
import mimetypes

class FileHandler:
    # Extended allowed extensions for code files
    ALLOWED_EXTENSIONS = {
        '.py', '.js', '.cpp', '.c', '.java', '.html', '.css', '.go', 
        '.sql', '.rb', '.rs', '.php', '.ts', '.jsx', '.tsx', '.vue',
        '.swift', '.kt', '.scala', '.sh', '.ps1', '.yml', '.yaml',
        '.json', '.xml', '.md'
    }
    MAX_FILE_SIZE = 500 * 1024  # Increased to 500KB for larger code files

    # Language detection mapping
    LANGUAGE_MAP = {
        '.py': 'python',
        '.js': 'javascript', 
        '.jsx': 'javascript',
        '.ts': 'typescript',
        '.tsx': 'typescript',
        '.java': 'java',
        '.cpp': 'cpp',
        '.c': 'c',
        '.go': 'go',
        '.sql': 'sql',
        '.rb': 'ruby',
        '.rs': 'rust',
        '.php': 'php',
        '.html': 'html',
        '.css': 'css',
        '.swift': 'swift',
        '.kt': 'kotlin',
        '.scala': 'scala',
        '.sh': 'bash',
        '.ps1': 'powershell',
        '.yml': 'yaml',
        '.yaml': 'yaml',
        '.json': 'json',
        '.xml': 'xml',
        '.md': 'markdown',
        '.vue': 'vue'
    }

    # MIME type mapping for downloads
    MIME_TYPES = {
        'code': 'text/plain',
        'markdown': 'text/markdown',
        'json': 'application/json',
        'xml': 'application/xml',
        'yaml': 'application/x-yaml'
    }

    @staticmethod
    def is_valid_file(file) -> bool:
        """Check if uploaded file is valid"""
        if not file:
            return False
        
        file_ext = os.path.splitext(file.name)[1].lower()
        return (
            file_ext in FileHandler.ALLOWED_EXTENSIONS and
            file.size <= FileHandler.MAX_FILE_SIZE
        )

    @staticmethod
    def get_file_info(file) -> Dict[str, Any]:
        """Get detailed information about the uploaded file"""
        if not file:
            return {}
        
        file_ext = os.path.splitext(file.name)[1].lower()
        return {
            'name': file.name,
            'size': file.size,
            'extension': file_ext,
            'language': FileHandler.LANGUAGE_MAP.get(file_ext, 'text'),
            'mime_type': mimetypes.guess_type(file.name)[0] or 'text/plain',
            'is_valid': FileHandler.is_valid_file(file)
        }

    @staticmethod
    def read_file_content(file) -> Optional[str]:
        """Read and return file content as string"""
        if not file or not FileHandler.is_valid_file(file):
            return None
        
        try:
            # Try different encodings
            encodings = ['utf-8', 'utf-16', 'latin-1', 'cp1252']
            content = None
            
            for encoding in encodings:
                try:
                    file.seek(0)  # Reset file pointer
                    content = file.read().decode(encoding)
                    break
                except UnicodeDecodeError:
                    continue
            
            if content is None:
                st.error("Could not decode file. Please ensure it's a valid text file.")
                return None
                
            return content
            
        except Exception as e:
            st.error(f"Error reading file: {str(e)}")
            return None

    @staticmethod
    def save_temp_file(uploaded_file) -> Optional[str]:
        """Save uploaded file to temporary location"""
        if uploaded_file is None:
            return None
        
        try:
            with tempfile.NamedTemporaryFile(
                delete=False, 
                suffix=os.path.splitext(uploaded_file.name)[1]
            ) as tmp:
                tmp.write(uploaded_file.getvalue())
                return tmp.name
        except Exception as e:
            st.error(f"Error saving file: {str(e)}")
            return None

    @staticmethod
    def create_download_content(content: str, content_type: str, metadata: Dict[str, Any] = None) -> str:
        """Create formatted content for download with metadata"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if content_type == "explanation":
            header = f"""Code Explanation Report
{'=' * 50}
Generated on: {timestamp}
Language: {metadata.get('language', 'Unknown')}
File: {metadata.get('filename', 'N/A')}
Difficulty: {metadata.get('difficulty', 'N/A')}
Focus Areas: {', '.join(metadata.get('focus_areas', []))}

Original Code:
{'-' * 20}
{metadata.get('code', '')}

Explanation:
{'-' * 20}
{content}

{'=' * 50}
Generated by Synthex Code Assistant
"""
        elif content_type == "code":
            header = f"""/*
Generated Code
{'=' * 30}
Language: {metadata.get('language', 'Unknown')}
Description: {metadata.get('description', 'N/A')}
Generated on: {timestamp}
Time Complexity: {metadata.get('time_complexity', 'N/A')}
Space Complexity: {metadata.get('space_complexity', 'N/A')}
{'=' * 30}
*/

{content}
"""
        else:
            header = f"""/*
Content Export
Generated on: {timestamp}
*/

{content}
"""
        
        return header

    @staticmethod
    def download_content(content: str, file_name: str, file_type: str, 
                        metadata: Dict[str, Any] = None, format_type: str = "txt"):
        """Enhanced download function with multiple format support"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Determine file extension and MIME type
        if format_type == "markdown":
            file_ext = ".md"
            mime_type = "text/markdown"
            if file_type == "explanation" and metadata:
                # Create markdown format for explanations
                content = f"""# Code Explanation

**Language:** {metadata.get('language', 'Unknown')}  
**File:** {metadata.get('filename', 'N/A')}  
**Generated on:** {timestamp}  
**Difficulty:** {metadata.get('difficulty', 'N/A')}  
**Focus Areas:** {', '.join(metadata.get('focus_areas', []))}

## Original Code
```{metadata.get('language', '').lower()}
{metadata.get('code', '')}
```

## Explanation
{content}

---
*Generated by Synthex Code Assistant*
"""
        elif format_type == "json" and metadata:
            file_ext = ".json"
            mime_type = "application/json"
            import json
            content = json.dumps({
                "timestamp": timestamp,
                "type": file_type,
                "metadata": metadata,
                "content": content
            }, indent=2)
        else:
            # Default to text format
            if file_type == "code":
                # Determine appropriate extension based on language
                lang_extensions = {
                    'python': '.py',
                    'javascript': '.js',
                    'java': '.java',
                    'cpp': '.cpp',
                    'c': '.c'
                }
                file_ext = lang_extensions.get(
                    metadata.get('language', '').lower(), '.txt'
                ) if metadata else '.txt'
            else:
                file_ext = ".txt"
            
            mime_type = "text/plain"
            content = FileHandler.create_download_content(content, file_type, metadata)
            
        full_filename = f"{file_name}_{timestamp}{file_ext}"
        
        st.download_button(
            label=f"ðŸ“¥ Download {file_type.title()} ({format_type.upper()})",
            data=content,
            file_name=full_filename,
            mime=mime_type,
            help=f"Download {file_type} as {format_type.upper()} file"
        )

    @staticmethod
    def get_supported_extensions() -> List[str]:
        """Return list of supported file extensions"""
        return sorted(list(FileHandler.ALLOWED_EXTENSIONS))

    @staticmethod
    def get_language_from_extension(file_ext: str) -> str:
        """Get programming language from file extension"""
        return FileHandler.LANGUAGE_MAP.get(file_ext.lower(), 'text')

    @staticmethod
    def cleanup_temp_file(file_path: str) -> None:
        """Clean up temporary file"""
        try:
            if os.path.exists(file_path):
                os.unlink(file_path)
        except Exception as e:
            st.warning(f"Could not clean up temporary file: {str(e)}")

    @staticmethod
    def validate_file_content(content: str, expected_language: str = None) -> Dict[str, Any]:
        """Validate and analyze file content"""
        validation_result = {
            'is_valid': True,
            'warnings': [],
            'suggestions': [],
            'stats': {}
        }
        
        # Basic content analysis
        lines = content.split('\n')
        validation_result['stats'] = {
            'lines': len(lines),
            'characters': len(content),
            'non_empty_lines': len([line for line in lines if line.strip()]),
        }
        
        # Check for common issues
        if len(content.strip()) == 0:
            validation_result['is_valid'] = False
            validation_result['warnings'].append("File appears to be empty")
        
        if validation_result['stats']['lines'] > 1000:
            validation_result['warnings'].append(
                "Large file detected. Consider breaking it into smaller parts for better analysis"
            )
        
        # Language-specific validations
        if expected_language:
            if expected_language.lower() == 'python':
                if 'def ' not in content and 'class ' not in content:
                    validation_result['suggestions'].append(
                        "No functions or classes detected. Consider adding some structure."
                    )
            elif expected_language.lower() == 'javascript':
                if 'function ' not in content and '=>' not in content:
                    validation_result['suggestions'].append(
                        "No functions detected. Consider adding some JavaScript functions."
                    )
        
        return validation_result